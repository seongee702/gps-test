<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GPS ë„ë³´ í…ŒìŠ¤í„° 11/17</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalmanjs@1.1.0/dist/kalman.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .btn:active { transform: scale(0.97); }
        .map-canvas { background-color: #1a202c; }
        .compass { 
            width: 60px; 
            height: 60px; 
            border: 2px solid #10B981; 
            border-radius: 50%; 
            position: relative; 
            background: rgba(0,0,0,0.7);
        }
        .compass::before { 
            content: 'ğŸ“±'; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 16px;
        }
        .direction-arrow { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: 2px; 
            height: 25px; 
            background: #EF4444; 
            transform-origin: bottom center; 
            transform: translate(-50%, -100%);
        }
        .direction-arrow::before { 
            content: 'â–²'; 
            position: absolute; 
            top: -8px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #EF4444; 
            font-size: 12px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center h-screen p-2 sm:p-4">

    <div class="w-full max-w-lg mx-auto flex flex-col h-full">
        <header class="text-center py-2">
            <h1 class="text-2xl font-bold text-cyan-400">GPS ë„ë³´ í…ŒìŠ¤í„° 11/17</h1>
            <p id="app-status" class="text-gray-400 text-sm">GPS ì‹ í˜¸ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
        </header>

        <div class="relative w-full flex-grow rounded-xl overflow-hidden border-2 border-cyan-500/30 my-2">
            <canvas id="mapCanvas" class="map-canvas"></canvas>
            <div class="absolute bottom-2 left-2 bg-black/50 p-2 rounded-lg text-xs leading-tight">
                <p><span class="text-green-400">ğŸŸ¢</span> í˜„ì¬ ìœ„ì¹˜ (GPS Haversine)</p>
                <p><span class="text-blue-400">ğŸ”µ</span> ì›¨ì´í¬ì¸íŠ¸</p>
                <p><span class="text-yellow-400">â˜…</span> ìµœê³  ì‹ í˜¸ ì§€ì </p>
            </div>
            <div class="absolute top-2 right-2 bg-black/50 p-2 rounded-full text-xs text-center font-sans">
                <div class="font-bold">N</div>
                <div>â¬†</div>
            </div>
            
            <!-- ğŸ“± GPS ë””ë²„ê·¸ ì •ë³´ íŒ¨ë„ -->
            <div class="absolute bottom-2 right-2 bg-black/80 p-3 rounded-lg text-xs font-mono text-green-300 max-w-xs">
                <div class="font-bold text-yellow-300 mb-2">ğŸ” GPS ë””ë²„ê·¸</div>
                <div id="debug-accuracy" class="truncate">ì •í™•ë„: -m</div>
                <div id="debug-status" class="truncate">ìƒíƒœ: ì´ˆê¸°í™”</div>
                <div id="debug-distance" class="truncate">ì´ë™: 0.0m</div>
                <div id="debug-speed" class="truncate">ì†ë„: 0.0 m/s</div>
                <div id="debug-filter" class="truncate text-cyan-300">í•„í„°: ëŒ€ê¸°</div>
                <div id="debug-count" class="truncate text-purple-300">ìˆ˜ìš©: 0 / ê±°ë¶€: 0</div>
            </div>
            
            <!-- ë°©í–¥ ë‚˜ì¹¨ë°˜ -->
            <div class="absolute top-2 left-2 bg-black/50 p-2 rounded-lg">
                <div class="compass" id="compass">
                    <div class="direction-arrow" id="direction-arrow"></div>
                </div>
                <div class="text-xs text-center mt-1">
                    <div>ë°©í–¥: <span id="bearing-display" class="text-cyan-400">0Â°</span></div>
                    <div>í°: <span id="phone-heading" class="text-green-400">0Â°</span></div>
                </div>
            </div>
        </div>

        <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
            <div id="status-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-3 text-sm mb-4">
                <div><span class="text-gray-400">ìƒëŒ€ ìœ„ì¹˜:</span> <span id="current-meter-display" class="font-mono text-white">(0.0, 0.0)m</span></div>
                <div><span class="text-gray-400">ëª©í‘œê¹Œì§€:</span> <span id="distance-display" class="font-mono font-bold text-green-400">0.0 m</span></div>
                <div><span class="text-gray-400">ì´ ì´ë™ ê±°ë¦¬:</span> <span id="total-distance-display" class="font-mono text-white">0.0 m</span></div>
                <div><span class="text-gray-400">ì•Œê³ ë¦¬ì¦˜:</span> <span id="state-display" class="font-mono text-yellow-300">IDLE</span></div>
                <div><span class="text-gray-400">Stuck:</span> <span id="stuck-display" class="font-mono text-red-400">0</span></div>
                <div><span class="text-gray-400">ìµœê³  ì‹ í˜¸:</span> <span id="best-signal-display" class="font-mono text-yellow-400">-100.0 dBm</span></div>
                <div><span class="text-gray-400">ì¶”ì • ì†ë„:</span> <span id="velocity-display" class="font-mono text-cyan-400">0.00 m/s</span></div>
                <div><span class="text-gray-400">í•„í„° ìƒíƒœ:</span> <span id="filter-status" class="font-mono text-purple-400">ì´ˆê¸°í™” ì¤‘</span></div>
            </div>

            <div id="log-section" class="hidden my-3">
                 <button id="download-log-button" class="btn w-full bg-gray-600 hover:bg-gray-700 font-bold py-2 px-4 rounded-lg text-sm">
                    ë¡œê·¸ ë‹¤ìš´ë¡œë“œ (<span id="log-count">0</span>ê°œ ê¸°ë¡)
                </button>
            </div>
            
            <div id="control-section" class="hidden">
                <label for="rssi-input" class="block mb-2 text-base font-medium text-green-300">ëª©í‘œ ë„ì°©! RSSI ê°’ì„ ì…ë ¥í•˜ì„¸ìš”:</label>
                <input type="number" id="rssi-input" class="bg-gray-700 border border-gray-600 text-white text-2xl font-bold rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-full p-3 text-center mb-3" placeholder="-55">
                <button id="submit-rssi-button" class="btn w-full text-white bg-green-500 hover:bg-green-600 font-bold rounded-lg text-lg px-5 py-3 transition-transform">
                    ë‹¤ìŒ ëª©í‘œ ê³„ì‚°
                </button>
            </div>
             <button id="start-button" class="btn w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-6 rounded-lg text-lg">í…ŒìŠ¤íŠ¸ ì‹œì‘</button>
        </div>
    </div>

    <script>
        // ì¹¼ë§Œ í•„í„° (í˜„ì¬ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ - Haversine ê±°ë¦¬ ê³„ì‚° ì‚¬ìš©)
        class KalmanFilter {
            constructor() {
                this.initialized = false;
            }
            reset() {
                this.initialized = false;
            }
            getVelocity() {
                return 0;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const startButton = document.getElementById('start-button');
            const appStatus = document.getElementById('app-status');
            const stateDisplay = document.getElementById('state-display');
            const stuckDisplay = document.getElementById('stuck-display');
            const currentMeterDisplay = document.getElementById('current-meter-display');
            const distanceDisplay = document.getElementById('distance-display');
            const controlSection = document.getElementById('control-section');
            const rssiInput = document.getElementById('rssi-input');
            const submitRssiButton = document.getElementById('submit-rssi-button');
            const totalDistanceDisplay = document.getElementById('total-distance-display');
            const bestSignalDisplay = document.getElementById('best-signal-display');
            const velocityDisplay = document.getElementById('velocity-display');
            const filterStatus = document.getElementById('filter-status');
            const logSection = document.getElementById('log-section');
            const downloadLogButton = document.getElementById('download-log-button');
            const logCount = document.getElementById('log-count');
            const bearingDisplay = document.getElementById('bearing-display');
            const phoneHeadingDisplay = document.getElementById('phone-heading');
            const directionArrow = document.getElementById('direction-arrow');
            
            // ğŸ“± ë””ë²„ê·¸ íŒ¨ë„ ìš”ì†Œ
            const debugAccuracy = document.getElementById('debug-accuracy');
            const debugStatus = document.getElementById('debug-status');
            const debugDistance = document.getElementById('debug-distance');
            const debugSpeed = document.getElementById('debug-speed');
            const debugFilter = document.getElementById('debug-filter');
            const debugCount = document.getElementById('debug-count');
            
            let logData = [];
            let originLat, originLon, algo;
            let isWaitingForRssi = false;
            const EARTH_RADIUS = 6378137.0;
            let camera = { x: 0, y: 0, zoom: 15 }; // ìˆ˜ì •

            let originBuffer = []; // [lat, lon] ìŒì„ ì €ì¥í•  ë°°ì—´
            const ORIGIN_SAMPLES_NEEDED = 10; // ì•ˆì •í™”ì— í•„ìš”í•œ ìƒ˜í”Œ ìˆ˜
            
            // ë°©í–¥ ê´€ë ¨ ë³€ìˆ˜
            let phoneHeading = 0;  // íœ´ëŒ€í° ë°©í–¥ (ë‚˜ì¹¨ë°˜)
            let targetBearing = 0; // ëª©í‘œ ì§€ì  ë°©í–¥
            
            // ì¹¼ë§Œ í•„í„° ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
            let kalmanFilter = new KalmanFilter();

            const PARAMS = {
                ARRIVAL_DISTANCE: 1.5,
                ASCENT_THRESHOLD: -80.0,
                TARGET_THRESHOLD: -50.0,
                SIGNAL_PINPOINT: -54.50,   DIST_PINPOINT: 1.25,
                SIGNAL_NEAR: -59.8,       DIST_NEAR: 3.15,
                SIGNAL_MID: -66.5,        DIST_MID: 6.20,
                DIST_FAR: 18.35,
                STUCK_THRESHOLD: 3,
                ESCAPE_DISTANCE: 25.5,
                RSSI_BUFFER_SIZE: 3,
                RSSI_IMPROVEMENT_THRESHOLD: 1.0,
                STATIONARY_SPEED_THRESHOLD: 0.5,
            };

            const vec = { 
                create: (x, y) => ({ x, y }), 
                add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }), 
                mul: (v, s) => ({ x: v.x * s, y: v.y * s }), 
                rotate: (v, angleRad) => ({ 
                    x: v.x * Math.cos(angleRad) - v.y * Math.sin(angleRad), 
                    y: v.x * Math.sin(angleRad) + v.y * Math.cos(angleRad) 
                }) 
            };

            function latlonToMeters(lat, lon) {
                if (!originLat) return vec.create(0, 0);
                const dx = (lon - originLon) * (EARTH_RADIUS * Math.cos(originLat * Math.PI / 180)) * (Math.PI / 180);
                const dy = (lat - originLat) * EARTH_RADIUS * (Math.PI / 180);
                return vec.create(dx, dy);
            }


            // ğŸŒ Haversine ê³µì‹: ìœ„ë„/ê²½ë„ ê¸°ë°˜ ê±°ë¦¬ ê³„ì‚° (ì ˆëŒ€ì¢Œí‘œ)
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = EARTH_RADIUS; // ì§€êµ¬ ë°˜ì§€ë¦„ (m)
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = 
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c; // ë¯¸í„° ë‹¨ìœ„
            }
            
            // ğŸ§­ ë°©í–¥ ê³„ì‚° (ìƒëŒ€ì¢Œí‘œ ê¸°ë°˜)
            function calculateBearing(from, to) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const bearing = Math.atan2(dx, dy) * 180 / Math.PI;
                return (bearing + 360) % 360;
            }

            // ë°©í–¥ í‘œì‹œ ì—…ë°ì´íŠ¸
            function updateDirection() {
                if (!algo || !algo.pos || !algo.waypoint) return;
                
                // ëª©í‘œ ë°©í–¥ ê³„ì‚°
                targetBearing = calculateBearing(algo.pos, algo.waypoint);
                bearingDisplay.textContent = `${targetBearing.toFixed(0)}Â°`;
                
                // ìƒëŒ€ì  ë°©í–¥ ê³„ì‚° (íœ´ëŒ€í° ë°©í–¥ ëŒ€ë¹„)
                const relativeBearing = (targetBearing - phoneHeading + 360) % 360;
                
                // í™”ì‚´í‘œ íšŒì „
                directionArrow.style.transform = `translate(-50%, -100%) rotate(${relativeBearing}deg)`;
            }

            // ì´ˆê¸°ê°’ ì„¤ì • í•¨ìˆ˜
            function setInitialValues() {
                currentMeterDisplay.textContent = "(0.0, 0.0)m";
                distanceDisplay.textContent = "0.0 m";
                totalDistanceDisplay.textContent = "0.0 m";
                stateDisplay.textContent = "IDLE";
                stuckDisplay.textContent = "0";
                bestSignalDisplay.textContent = "-1000.0 dBm";
                velocityDisplay.textContent = "0.00 m/s";
                filterStatus.textContent = "ì´ˆê¸°í™” ì¤‘";
                bearingDisplay.textContent = "0Â°";
                phoneHeadingDisplay.textContent = "0Â°";
                
                // í™”ì‚´í‘œ ë¶ìª½ ë°©í–¥ìœ¼ë¡œ ì´ˆê¸°í™”
                directionArrow.style.transform = `translate(-50%, -100%) rotate(0deg)`;
            }

            class HomingAlgorithm {
                constructor(startPos, params) { 
                    Object.assign(this, { 
                        pos: startPos, waypoint: startPos, path: [startPos], params, isFinished: false, 
                        state: "IDLE", lastSmoothedSignal: -100.0, stuck_counter: 0, 
                        best_known_pos: startPos, best_known_signal: -100.0, 
                        ascentDirection: vec.create(1, 0), rssiBuffer: [],
                    }); 
                }
                decideAction(rssi) {
                    if (this.isFinished) return;
                    this.rssiBuffer.push(rssi);
                    if (this.rssiBuffer.length > this.params.RSSI_BUFFER_SIZE) this.rssiBuffer.shift();
                    const smoothedRssi = this.rssiBuffer.reduce((a, b) => a + b, 0) / this.rssiBuffer.length;
                    
                    if (smoothedRssi > this.best_known_signal) { this.best_known_signal = smoothedRssi; this.best_known_pos = this.pos; }
                    if (smoothedRssi >= this.params.TARGET_THRESHOLD) { this.state = "FINISHED"; this.isFinished = true; return; }
                    if (this.state === "IDLE") this._executeIdle(smoothedRssi); 
                    else if (this.state === "ADAPTIVE_ASCENT") this._executeAdaptiveAscent(smoothedRssi); 
                    else if (this.state === "ESCAPING") this._executeEscaping(smoothedRssi);
                    this.lastSmoothedSignal = smoothedRssi;
                }
                getTotalDistance() {
                    let total = 0;
                    for (let i = 1; i < this.path.length; i++) total += Math.hypot(this.path[i].x - this.path[i-1].x, this.path[i].y - this.path[i-1].y);
                    return total;
                }
                _getAdaptiveDistance(signal) {
                    if (signal > this.params.SIGNAL_PINPOINT) return this.params.DIST_PINPOINT;
                    if (signal > this.params.SIGNAL_NEAR) return this.params.DIST_NEAR;
                    if (signal > this.params.SIGNAL_MID) return this.params.DIST_MID;
                    return this.params.DIST_FAR;
                }
                _executeIdle(rssi) {
                    if (rssi > this.params.ASCENT_THRESHOLD) { 
                        this.state = "ADAPTIVE_ASCENT"; 
                        const angle = Math.random() * Math.PI * 2; this.ascentDirection = vec.create(Math.cos(angle), Math.sin(angle)); 
                        this._executeAdaptiveAscent(rssi); 
                    } else { this.waypoint = this.pos; }
                }
                _executeAdaptiveAscent(rssi) {
                    if (rssi > this.lastSmoothedSignal + this.params.RSSI_IMPROVEMENT_THRESHOLD) {
                        this.stuck_counter = 0; 
                        const stepDistance = this._getAdaptiveDistance(rssi); 
                        this.waypoint = vec.add(this.pos, vec.mul(this.ascentDirection, stepDistance)); 
                    } else { 
                        this.stuck_counter++; 
                        if (this.stuck_counter > this.params.STUCK_THRESHOLD) { 
                            this.state = "ESCAPING"; this.waypoint = this.best_known_pos; return; 
                        } 
                        this.waypoint = this.pos; 
                        this.ascentDirection = vec.rotate(this.ascentDirection, Math.PI / 2.5);
                    }
                }
                _executeEscaping(rssi) { 
                    const angle = Math.random() * Math.PI * 2; 
                    this.ascentDirection = vec.create(Math.cos(angle), Math.sin(angle)); 
                    this.waypoint = vec.add(this.best_known_pos, vec.mul(this.ascentDirection, this.params.ESCAPE_DISTANCE)); 
                    this.state = "ADAPTIVE_ASCENT"; this.stuck_counter = 0; 
                }
                updatePosition(newPos) {
                    if (!this.path.length) this.path.push(newPos);
                    const lastPathPoint = this.path[this.path.length - 1];
                    if (Math.hypot(lastPathPoint.x - newPos.x, lastPathPoint.y - newPos.y) < 0.1) return;
                    this.pos = newPos; this.path.push(newPos);
                }
            }

            function draw() {
                if (!algo) return;
                const w = canvas.width, h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                camera.x += (algo.pos.x - camera.x) * 0.1; camera.y += (algo.pos.y - camera.y) * 0.1;
                ctx.save();
                ctx.translate(w / 2, h / 2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)"; ctx.lineWidth = 1 / camera.zoom;
                const gridSize = 10;
                const viewBounds = { left: camera.x - (w / 2 / camera.zoom), right: camera.x + (w / 2 / camera.zoom), top: camera.y - (h / 2 / camera.zoom), bottom: camera.y + (h / 2 / camera.zoom) };
                for (let x = Math.floor(viewBounds.left / gridSize) * gridSize; x < viewBounds.right; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, viewBounds.top); ctx.lineTo(x, viewBounds.bottom); ctx.stroke(); }
                for (let y = Math.floor(viewBounds.top / gridSize) * gridSize; y < viewBounds.bottom; y += gridSize) { ctx.beginPath(); ctx.moveTo(viewBounds.left, y); ctx.lineTo(viewBounds.right, y); ctx.stroke(); }
                if (algo.path.length > 1) {
                    ctx.strokeStyle = "#4A5568"; ctx.lineWidth = 2 / camera.zoom; ctx.beginPath();
                    ctx.moveTo(algo.path[0].x, algo.path[0].y);
                    for (let i = 1; i < algo.path.length; i++) { ctx.lineTo(algo.path[i].x, algo.path[i].y); }
                    ctx.stroke();
                }
                ctx.font = `${12 / camera.zoom}px Arial`; ctx.fillStyle = "#FBBF24"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText("â˜…", algo.best_known_pos.x, algo.best_known_pos.y);
                ctx.fillStyle = "#4299E1"; ctx.beginPath(); ctx.arc(algo.waypoint.x, algo.waypoint.y, 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#48BB78"; ctx.beginPath(); ctx.arc(algo.pos.x, algo.pos.y, 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                requestAnimationFrame(draw);
            }

            // GPS ì •í™•ë„ í•„í„°ë§ ìƒíƒœ
            let gpsAccuracyStats = {
                acceptedCount: 0,
                rejectedCount: 0,
                averageAccuracy: 0
            };
            
            // GPS ì—…ë°ì´íŠ¸ ì£¼ê¸° ì œí•œ (500msë§ˆë‹¤ë§Œ ê°±ì‹ )
            let lastGpsUpdateTime = 0;
            const GPS_UPDATE_INTERVAL = 500; // ms
            
            // ì´ì „ GPS ìœ„ì¹˜ (ê¸‰ê²©í•œ ì›€ì§ì„ í•„í„°ë§ìš©) - ì´ì œ ìœ„ë„/ê²½ë„ë¡œ ì €ì¥
            let lastFilteredLat = null;
            let lastFilteredLon = null;
            let lastGpsTime = 0;
            const MAX_SPEED = 3.5; // m/s (ì•½ 12.6 km/h - ë„ë³´/ë‹¬ë¦¬ê¸° í•œê³„)
            const MIN_MOVE_DISTANCE = 1.0; // m (1m ë¯¸ë§Œ ë³€í™”ëŠ” ë…¸ì´ì¦ˆë¡œ ë¬´ì‹œ)

            // ğŸŒ í•µì‹¬ ìˆ˜ì •: GPS ì ˆëŒ€ì¢Œí‘œ(ìœ„ë„/ê²½ë„) ê¸°ë°˜ ê±°ë¦¬ ê³„ì‚°ìœ¼ë¡œ ë³€ê²½
            /*
            function handleGpsSuccess(position) {
                // â± 1ë‹¨ê³„: GPS ì—…ë°ì´íŠ¸ ì£¼ê¸° ì œí•œ (500msë§ˆë‹¤ë§Œ)
                const currentTime = Date.now();
                if (currentTime - lastGpsUpdateTime < GPS_UPDATE_INTERVAL) {
                    return; // ì•„ì§ ì‹œê°„ì´ ì•ˆ ë˜ì—ˆìœ¼ë¯€ë¡œ ë¬´ì‹œ
                }
                lastGpsUpdateTime = currentTime;
                
                const accuracy = position.coords.accuracy;
                
                //const currentLat = position.coords.latitude;
                //const currentLon = position.coords.longitude;
                const rawLat = position.coords.latitude; // â¬…ï¸ ì´ë ‡ê²Œ ë³€ê²½
                const rawLon = position.coords.longitude; // â¬…ï¸ ì´ë ‡ê²Œ ë³€ê²½
                
                // ì›ì  ì„¤ì • ì‹œì—ëŠ” ì •í™•ë„ í•„í„°ë§í•˜ì§€ ì•ŠìŒ
            if (!originLat) {
        // ì›ì ì´ ì•„ì§ ì„¤ì •ë˜ì§€ ì•Šì•˜ë‹¤ë©´ (ì•ˆì •í™” ì§„í–‰ ì¤‘
        // â­ 1ë‹¨ê³„: ì •í™•ë„ í•„í„° (30m ê¸°ì¤€)
                if (accuracy > 30) {
                    appStatus.textContent = `ì‹ í˜¸ê°€ ì•½í•©ë‹ˆë‹¤ (Â±${accuracy.toFixed(1)}m). ì•ˆì •ì ì¸ ì‹ í˜¸ ê²€ìƒ‰ ì¤‘...`;
                    return; // ì •í™•ë„ê°€ ë‚˜ìœ ì‹ í˜¸ëŠ” ë²„í¼ì— ì¶”ê°€í•˜ì§€ ì•ŠìŒ
                }
        
        // âœ… 2ë‹¨ê³„: ë²„í¼ì— ì¶”ê°€
                originBuffer.push({ lat: rawLat, lon: rawLon });
                appStatus.textContent = `ì•ˆì •ì ì¸ ì›ì  ì„¤ì • ì¤‘... (${originBuffer.length}/${ORIGIN_SAMPLES_NEEDED})`;
        
        // 3ë‹¨ê³„: ë²„í¼ê°€ ë‹¤ ì°¼ëŠ”ì§€ í™•ì¸
            if (originBuffer.length >= ORIGIN_SAMPLES_NEEDED) {
                // 4ë‹¨ê³„: í‰ê·  ê³„ì‚°
                let avgLat = 0, avgLon = 0;
                for (const pos of originBuffer) {
                    avgLat += pos.lat;
                    avgLon += pos.lon;
                }
                avgLat /= originBuffer.length;
                avgLon /= originBuffer.length;
            
            // 5ë‹¨ê³„: ê³„ì‚°ëœ í‰ê· ê°’ì„ ì›ì ìœ¼ë¡œ ì„¤ì •!
                originLat = avgLat;
                originLon = avgLon;
            
            // 6ë‹¨ê³„: ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì‹œì‘ ë²„íŠ¼ í™œì„±í™”
                appStatus.textContent = "ì›ì  ì„¤ì • ì™„ë£Œ. í…ŒìŠ¤íŠ¸ë¥¼ ì‹œì‘í•˜ì„¸ìš”.";
                startButton.style.display = 'block';
                console.log(`ğŸ“ ì•ˆì •í™”ëœ ì›ì  ì„¤ì • ì™„ë£Œ (ì‹ í˜¸ ${ORIGIN_SAMPLES_NEEDED}ê°œ í‰ê· )`);
                }
            return; // ì›ì ì´ ì„¤ì •ë˜ì—ˆê±°ë‚˜(ë°©ê¸ˆ) ì•„ì§ ì•ˆë˜ì—ˆìœ¼ë¯€ë¡œ(ìˆ˜ì§‘ì¤‘) ì•Œê³ ë¦¬ì¦˜ ë¡œì§ì€ ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
            }
                
                // â­ 2ë‹¨ê³„: ì •í™•ë„ í•„í„° (30m ê¸°ì¤€ - í•„ë“œ í™˜ê²½ ìµœì í™”)
                if (accuracy > 30) {
                    gpsAccuracyStats.rejectedCount++;
                    debugAccuracy.textContent = `ì •í™•ë„: Â±${accuracy.toFixed(1)}m âš ï¸`;
                    debugStatus.textContent = `ìƒíƒœ: âœ— ê±°ë¶€ë¨`;
                    debugFilter.textContent = `í•„í„°: ì •í™•ë„ ë‚®ìŒ`;
                    debugFilter.className = 'truncate text-red-400';
                    debugCount.textContent = `ìˆ˜ìš©: ${gpsAccuracyStats.acceptedCount} / ê±°ë¶€: ${gpsAccuracyStats.rejectedCount}`;
                    return;
                }
                
                gpsAccuracyStats.acceptedCount++;
                gpsAccuracyStats.averageAccuracy = gpsAccuracyStats.averageAccuracy * 0.8 + accuracy * 0.2;
                
                if (!algo) return;
                
                // ğŸŒ 3ë‹¨ê³„: Haversine ê±°ë¦¬ë¡œ ê¸‰ê²©í•œ ì›€ì§ì„ í•„í„°ë§ (ì ˆëŒ€ì¢Œí‘œ ê¸°ë°˜)
                if (lastFilteredLat !== null && lastFilteredLon !== null && lastGpsTime > 0) {
                    const realTimeDelta = (currentTime - lastGpsTime) / 1000;
                    //const distance = haversineDistance(lastFilteredLat, lastFilteredLon, currentLat, currentLon);
                    const distance = haversineDistance(lastFilteredLat, lastFilteredLon, rawLat, rawLon); // â¬…ï¸ ì´ë ‡ê²Œ ë³€ê²½ (ì›ì‹œ ê°’ê³¼ ë¹„êµ)
                    const estimatedSpeed = realTimeDelta > 0 ? distance / realTimeDelta : 0;
                    
                    // ì†ë„ê°€ MAX_SPEEDë¥¼ ì´ˆê³¼í•˜ë©´ ë¶€ì •í™•í•œ ì‹ í˜¸ë¡œ íŒë‹¨
                    if (estimatedSpeed > MAX_SPEED) {
                        // ğŸ“± ë””ë²„ê·¸: ì†ë„ ì´ìƒ ì‹ í˜¸ ì •ë³´
                        debugSpeed.textContent = `ì†ë„: ${estimatedSpeed.toFixed(2)} m/s âš ï¸`;
                        debugFilter.textContent = `í•„í„°: ì†ë„ ì´ìƒ`;
                        debugFilter.className = 'truncate text-red-400';
                        return;
                    }
                    
                    // ğŸ”¥ 4ë‹¨ê³„: ìµœì†Œ ì´ë™ ê±°ë¦¬ í•„í„° (1m ë¯¸ë§Œì€ ë…¸ì´ì¦ˆ)
                    if (distance < MIN_MOVE_DISTANCE) {
                        // ï¿½ ë””ë²„ê·¸: ë¯¸ì†Œ ì›€ì§ì„ ì •ë³´
                        debugDistance.textContent = `ì´ë™: ${distance.toFixed(2)}m (ë…¸ì´ì¦ˆ)`;
                        debugFilter.textContent = `í•„í„°: ë¯¸ì†Œ ì›€ì§ì„`;
                        debugFilter.className = 'truncate text-yellow-400';
                        return;
                    }
                }
                // ğŸ”¥ [ì¶”ê°€] 5ë‹¨ê³„: EMA(ì§€ìˆ˜ ì´ë™ í‰ê· ) ìŠ¤ë¬´ë”© ì ìš©
                // (0.0 ~ 1.0 ì‚¬ì´ ê°’, 1.0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ìƒˆ ê°’ì„, 0.0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì´ì „ ê°’ì„ ì‹ ë¢°)
                // ì´ ê°’ì„ ì¡°ì ˆí•˜ë©° ê°€ì¥ ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ì„ ì°¾ì•„ë³´ì„¸ìš”. (ì˜ˆ: 0.6)
                const SMOOTHING_FACTOR = 0.6; 
        
                let currentLat, currentLon; // â¬…ï¸ [ì¶”ê°€] ìµœì¢… ì‚¬ìš©í•  ìœ„ì¹˜ ë³€ìˆ˜ ì„ ì–¸
        
                if (lastFilteredLat === null || lastFilteredLon === null) {
                    // ìµœì´ˆ 1íšŒëŠ” ì›ì‹œ ê°’ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    currentLat = rawLat;
                    currentLon = rawLon;
                } else {
                    // (ìƒˆë¡œìš´ ì›ì‹œ ê°’ * ê°€ì¤‘ì¹˜) + (ì´ì „ ìŠ¤ë¬´ë”© ê°’ * (1 - ê°€ì¤‘ì¹˜))
                    currentLat = (rawLat * SMOOTHING_FACTOR) + (lastFilteredLat * (1.0 - SMOOTHING_FACTOR));
                    currentLon = (rawLon * SMOOTHING_FACTOR) + (lastFilteredLon * (1.0 - SMOOTHING_FACTOR));
                }
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                //const currentPosMeters = latlonToMeters(currentLat, currentLon);
                const currentPosMeters = latlonToMeters(currentLat, currentLon);
                algo.updatePosition(currentPosMeters);
                
                // ì†ë„ ì§ì ‘ ê³„ì‚° (Haversine ê±°ë¦¬ ê¸°ë°˜)
                let estimatedSpeed = 0;
                let smoothedDistance = 0; // â¬…ï¸ [ì¶”ê°€] ìŠ¤ë¬´ë”©ëœ ì´ë™ ê±°ë¦¬ë¥¼ ì €ì¥í•  ë³€ìˆ˜
                if (lastFilteredLat !== null && lastFilteredLon !== null && lastGpsTime > 0) {
                    const timeDelta = (currentTime - lastGpsTime) / 1000;
                    const distance = haversineDistance(lastFilteredLat, lastFilteredLon, currentLat, currentLon);
                    if (timeDelta > 0) {
                        estimatedSpeed = distance / timeDelta;
                    }
                }
                
                // ë‹¤ìŒ ê³„ì‚°ì„ ìœ„í•´ í˜„ì¬ ê°’(ì ˆëŒ€ì¢Œí‘œ)ì„ ì´ì „ ê°’ìœ¼ë¡œ ì €ì¥
                //lastFilteredLat = currentLat;
                //lastFilteredLon = currentLon;
                lastFilteredLat = currentLat; // â¬…ï¸ ìŠ¤ë¬´ë”©ëœ ê°’ìœ¼ë¡œ ì €ì¥
                lastFilteredLon = currentLon; // â¬…ï¸ ìŠ¤ë¬´ë”©ëœ ê°’ìœ¼ë¡œ ì €ì¥
                lastGpsTime = currentTime;
                
                // UI ìƒíƒœ ì •ë³´ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                stateDisplay.textContent = algo.state; 
                stuckDisplay.textContent = algo.stuck_counter;
                currentMeterDisplay.textContent = `(${currentPosMeters.x.toFixed(1)}, ${currentPosMeters.y.toFixed(1)})m`;
                const dist = Math.hypot(algo.waypoint.x - currentPosMeters.x, algo.waypoint.y - currentPosMeters.y);
                distanceDisplay.textContent = `${dist.toFixed(1)} m`;
                totalDistanceDisplay.textContent = `${algo.getTotalDistance().toFixed(1)} m`;
                bestSignalDisplay.textContent = `${algo.best_known_signal.toFixed(1)} dBm`;
                
                // ì†ë„ í‘œì‹œ (ì¹¼ë§Œ í•„í„° ì œê±°)
                velocityDisplay.textContent = `${estimatedSpeed.toFixed(2)} m/s`;
                filterStatus.textContent = `ì •ìƒ (Â±${gpsAccuracyStats.averageAccuracy.toFixed(1)}m)`;
                
                // ğŸ“± ë””ë²„ê·¸ íŒ¨ë„ ì—…ë°ì´íŠ¸
                debugAccuracy.textContent = `ì •í™•ë„: Â±${accuracy.toFixed(1)}m`;
                debugStatus.textContent = `ìƒíƒœ: âœ“ ìˆ˜ìš©ë¨`;
                debugDistance.textContent = `ì´ë™: ${smoothedDistance.toFixed(2)}m`; // â¬…ï¸ [ìˆ˜ì •] ë¯¸ë¦¬ ê³„ì‚°í•œ ë³€ìˆ˜ ì‚¬ìš©
                debugSpeed.textContent = `ì†ë„: ${estimatedSpeed.toFixed(2)} m/s`;
                debugFilter.textContent = `í•„í„°: âœ“ í†µê³¼`;
                debugFilter.className = 'truncate text-green-400';
                debugCount.textContent = `ìˆ˜ìš©: ${gpsAccuracyStats.acceptedCount} / ê±°ë¶€: ${gpsAccuracyStats.rejectedCount}`;
                
                // ë°©í–¥ ì—…ë°ì´íŠ¸
                updateDirection();
                
                // ëª©í‘œ ë„ì°© ì²´í¬
                if (dist < PARAMS.ARRIVAL_DISTANCE && !isWaitingForRssi) {
                    isWaitingForRssi = true; 
                    controlSection.style.display = 'block';
                    appStatus.textContent = "ëª©í‘œ ë„ì°©! RSSIë¥¼ ì…ë ¥í•˜ì„¸ìš”."; 
                    rssiInput.focus();
                }
            }
            */
            // ğŸŒ [ìˆ˜ì •ë¨] GPS ì ˆëŒ€ì¢Œí‘œ ë° 'ìˆ˜ë™ ê±°ë¦¬/ì†ë„' ê¸°ë°˜ í•„í„°ë§
Â  Â  Â  Â  Â  Â  function handleGpsSuccess(position) {
Â  Â  Â  Â  Â  Â  Â  Â  const currentTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  // 1. Time check
Â  Â  Â  Â  Â  Â  Â  Â  if (currentTime - lastGpsUpdateTime < GPS_UPDATE_INTERVAL) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return; // ì•„ì§ ì‹œê°„ì´ ì•ˆ ë˜ì—ˆìœ¼ë¯€ë¡œ ë¬´ì‹œ
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // (ì„±ê³µ ì‹œ ë§ˆì§€ë§‰ì— lastGpsUpdateTimeê³¼ lastGpsTimeì„ ê°±ì‹ í•©ë‹ˆë‹¤)
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // 2. Get Coords
Â  Â  Â  Â  Â  Â  Â  Â  const accuracy = position.coords.accuracy;
Â  Â  Â  Â  Â  Â  Â  Â  const rawLat = position.coords.latitude;
Â  Â  Â  Â  Â  Â  Â  Â  const rawLon = position.coords.longitude;

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Origin check (with bug fix)
Â  Â  Â  Â  Â  Â  Â  Â  if (!originLat) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (accuracy > 30) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  appStatus.textContent = `ì‹ í˜¸ê°€ ì•½í•©ë‹ˆë‹¤ (Â±${accuracy.toFixed(1)}m). ì•ˆì •ì ì¸ ì‹ í˜¸ ê²€ìƒ‰ ì¤‘...`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  originBuffer.push({ lat: rawLat, lon: rawLon }); // [ë²„ê·¸ ìˆ˜ì •]
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  appStatus.textContent = `ì•ˆì •ì ì¸ ì›ì  ì„¤ì • ì¤‘... (${originBuffer.length}/${ORIGIN_SAMPLES_NEEDED})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (originBuffer.length >= ORIGIN_SAMPLES_NEEDED) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let avgLat = 0, avgLon = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (const pos of originBuffer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  avgLat += pos.lat;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  avgLon += pos.lon;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  originLat = avgLat / originBuffer.length;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  originLon = avgLon / originBuffer.length;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  appStatus.textContent = "ì›ì  ì„¤ì • ì™„ë£Œ. í…ŒìŠ¤íŠ¸ë¥¼ ì‹œì‘í•˜ì„¸ìš”.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startButton.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ ì•ˆì •í™”ëœ ì›ì  ì„¤ì • ì™„ë£Œ (ì‹ í˜¸ ${ORIGIN_SAMPLES_NEEDED}ê°œ í‰ê· )`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return; // ì›ì  ì„¤ì • ì¤‘ì—ëŠ” ì•„ë˜ ë¡œì§ ì‹¤í–‰ ì•ˆ í•¨
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 4. Accuracy filter
Â  Â  Â  Â  Â  Â  Â  Â  if (accuracy > 30) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gpsAccuracyStats.rejectedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugAccuracy.textContent = `ì •í™•ë„: Â±${accuracy.toFixed(1)}m âš ï¸`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugStatus.textContent = `ìƒíƒœ: âœ— ê±°ë¶€ë¨`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.textContent = `í•„í„°: ì •í™•ë„ ë‚®ìŒ`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.className = 'truncate text-red-400';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugCount.textContent = `ìˆ˜ìš©: ${gpsAccuracyStats.acceptedCount} / ê±°ë¶€: ${gpsAccuracyStats.rejectedCount}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return; // ì‹ í˜¸ ë‚˜ì˜ë©´ ê°±ì‹  ì•ˆ í•¨
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  gpsAccuracyStats.acceptedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  gpsAccuracyStats.averageAccuracy = gpsAccuracyStats.averageAccuracy * 0.8 + accuracy * 0.2;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (!algo) return;

Â  Â  Â  Â  Â  Â  Â  Â  // 5. [ë³µì›] ìˆ˜ë™ ì†ë„/ê±°ë¦¬ í•„í„° (ì›ë˜ ì½”ë“œì˜ ë°©ì‹)
Â  Â  Â  Â  Â  Â  Â  Â  let estimatedSpeed = 0;
Â  Â  Â  Â  Â  Â  Â  Â  let rawDistance = 0; // ì›ì‹œ GPS ì‹ í˜¸ê°€ íŠ„ ê±°ë¦¬
Â  Â  Â  Â  Â  Â  Â  Â  let realTimeDelta = 0;

Â  Â  Â  Â  Â  Â  Â  Â  if (lastFilteredLat !== null && lastFilteredLon !== null && lastGpsTime > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  realTimeDelta = (currentTime - lastGpsTime) / 1000;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // [ì¤‘ìš”] ê±°ë¦¬ë¥¼ 'ìŠ¤ë¬´ë”©ëœ ë§ˆì§€ë§‰ ìœ„ì¹˜'ì™€ 'ìƒˆë¡œìš´ ì›ì‹œ ìœ„ì¹˜'ë¡œ ê³„ì‚°
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rawDistance = haversineDistance(lastFilteredLat, lastFilteredLon, rawLat, rawLon); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (realTimeDelta > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  estimatedSpeed = rawDistance / realTimeDelta;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // í•„í„° 1: Max Speed (í° íŠ ë°©ì§€)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (estimatedSpeed > MAX_SPEED) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugSpeed.textContent = `ì†ë„: ${estimatedSpeed.toFixed(2)} m/s âš ï¸`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.textContent = `í•„í„°: ì†ë„ ì´ìƒ`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.className = 'truncate text-red-400';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return; // ê°±ì‹  ì•ˆ í•¨
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // í•„í„° 2: Min Distance (ì •ì§€ ìƒíƒœ Jitter ë°©ì§€ - Dead Zone)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (rawDistance < MIN_MOVE_DISTANCE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugDistance.textContent = `ì´ë™: ${rawDistance.toFixed(2)}m (ë…¸ì´ì¦ˆ)`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.textContent = `í•„í„°: ë¯¸ì†Œ ì›€ì§ì„`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.className = 'truncate text-yellow-400';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debugSpeed.textContent = `ì†ë„: ${estimatedSpeed.toFixed(2)} m/s`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return; // ìœ„ì¹˜ ê°±ì‹  ì•ˆ í•¨
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 6. [ì´ë™ ìƒíƒœ] EMA ìŠ¤ë¬´ë”© ì ìš©
Â  Â  Â  Â  Â  Â  Â  Â  const SMOOTHING_FACTOR = 0.6; // 0.0 (ëŠë¦¼/ë¶€ë“œëŸ¬ì›€) ~ 1.0 (ë¹ ë¦„/ë‚ ê²ƒ)
Â  Â  Â  Â  Â  Â  Â  Â  let currentLat, currentLon;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (lastFilteredLat === null || lastFilteredLon === null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentLat = rawLat;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentLon = rawLon;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentLat = (rawLat * SMOOTHING_FACTOR) + (lastFilteredLat * (1.0 - SMOOTHING_FACTOR));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentLon = (rawLon * SMOOTHING_FACTOR) + (lastFilteredLon * (1.0 - SMOOTHING_FACTOR));
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // 7. ìœ„ì¹˜ ë° UI ì—…ë°ì´íŠ¸
Â  Â  Â  Â  Â  Â  Â  Â  const currentPosMeters = latlonToMeters(currentLat, currentLon);
Â  Â  Â  Â  Â  Â  Â  Â  algo.updatePosition(currentPosMeters);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // [ë²„ê·¸ ìˆ˜ì •] ë‹¤ìŒ í”„ë ˆì„ ê³„ì‚°ì„ ìœ„í•´ í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥
Â  Â  Â  Â  Â  Â  Â  Â  lastFilteredLat = currentLat;
Â  Â  Â  Â  Â  Â  Â  Â  lastFilteredLon = currentLon;
Â  Â  Â  Â  Â  Â  Â  Â  lastGpsTime = currentTime; 
Â  Â  Â  Â  Â  Â  Â  Â  lastGpsUpdateTime = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // UI ìƒíƒœ ì •ë³´ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
Â  Â  Â  Â  Â  Â  Â  Â  stateDisplay.textContent = algo.state;Â 
Â  Â  Â  Â  Â  Â  Â  Â  stuckDisplay.textContent = algo.stuck_counter;
Â  Â  Â  Â  Â  Â  Â  Â  currentMeterDisplay.textContent = `(${currentPosMeters.x.toFixed(1)}, ${currentPosMeters.y.toFixed(1)})m`;
Â  Â  Â  Â  Â  Â  Â  Â  const dist = Math.hypot(algo.waypoint.x - currentPosMeters.x, algo.waypoint.y - currentPosMeters.y);
Â  Â  Â  Â  Â  Â  Â  Â  distanceDisplay.textContent = `${dist.toFixed(1)} m`;
Â  Â  Â  Â  Â  Â  Â  Â  totalDistanceDisplay.textContent = `${algo.getTotalDistance().toFixed(1)} m`;
Â  Â  Â  Â  Â  Â  Â  Â  bestSignalDisplay.textContent = `${algo.best_known_signal.toFixed(1)} dBm`;
Â  Â  Â  Â  Â  Â  Â  Â  velocityDisplay.textContent = `${estimatedSpeed.toFixed(2)} m/s`;
Â  Â  Â  Â  Â  Â  Â  Â  filterStatus.textContent = `ì •ìƒ (Â±${gpsAccuracyStats.averageAccuracy.toFixed(1)}m)`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // ğŸ“± ë””ë²„ê·¸ íŒ¨ë„ ì—…ë°ì´íŠ¸
Â  Â  Â  Â  Â  Â  Â  Â  debugAccuracy.textContent = `ì •í™•ë„: Â±${accuracy.toFixed(1)}m`;
Â  Â  Â  Â  Â  Â  Â  Â  debugStatus.textContent = `ìƒíƒœ: âœ“ ìˆ˜ìš©ë¨ (ì´ë™)`;
Â  Â  Â  Â  Â  Â  Â  Â  // [ë²„ê·¸ ìˆ˜ì •] 0.0m ëŒ€ì‹  'ì›ì‹œ ì´ë™ ê±°ë¦¬'ë¥¼ í‘œì‹œ
Â  Â  Â  Â  Â  Â  Â  Â  debugDistance.textContent = `ì´ë™: ${rawDistance.toFixed(2)}m`;
Â  Â  Â  Â  Â  Â  Â  Â  debugSpeed.textContent = `ì†ë„: ${estimatedSpeed.toFixed(2)} m/s`;
Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.textContent = `í•„í„°: âœ“ í†µê³¼ (ì´ë™ ì¤‘)`;
Â  Â  Â  Â  Â  Â  Â  Â  debugFilter.className = 'truncate text-green-400';
Â  Â  Â  Â  Â  Â  Â  Â  debugCount.textContent = `ìˆ˜ìš©: ${gpsAccuracyStats.acceptedCount} / ê±°ë¶€: ${gpsAccuracyStats.rejectedCount}`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // ë°©í–¥ ì—…ë°ì´íŠ¸
Â  Â  Â  Â  Â  Â  Â  Â  updateDirection();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // ëª©í‘œ ë„ì°© ì²´í¬
Â  Â  Â  Â  Â  Â  Â  Â  if (dist < PARAMS.ARRIVAL_DISTANCE && !isWaitingForRssi) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isWaitingForRssi = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  controlSection.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  appStatus.textContent = "ëª©í‘œ ë„ì°©! RSSIë¥¼ ì…ë ¥í•˜ì„¸ìš”.";Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rssiInput.focus();
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

            // íœ´ëŒ€í° ë°©í–¥ ê°ì§€
            function handleOrientationChange(event) {
                if (event.alpha !== null) {
                    phoneHeading = event.alpha;
                    phoneHeadingDisplay.textContent = `${phoneHeading.toFixed(0)}Â°`;
                    updateDirection();
                }
            }

            // Device Orientation API ê¶Œí•œ ìš”ì²­
            async function requestOrientationPermission() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientationChange);
                        } else {
                            console.log('Device orientation permission denied');
                        }
                    } catch (error) {
                        console.log('Device orientation not supported');
                    }
                } else {
                    window.addEventListener('deviceorientation', handleOrientationChange);
                }
            }
            
            startButton.addEventListener('click', () => {
                if (!originLat) {   
                    alert("ì•„ì§ GPS ì›ì ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”."); 
                    return; 
                }
                
                // ì•Œê³ ë¦¬ì¦˜ ì´ˆê¸°í™”
                algo = new HomingAlgorithm(vec.create(0, 0), PARAMS);
                
                // ì¹¼ë§Œ í•„í„° ì´ˆê¸°í™”
                kalmanFilter.reset();
                
                // ë¡œê·¸ ì´ˆê¸°í™”
                logData = []; 
                logCount.textContent = '0';
                logSection.style.display = 'block'; 
                
                // UI ìƒíƒœ ë³€ê²½
                isWaitingForRssi = true; 
                startButton.style.display = 'none'; 
                controlSection.style.display = 'block';
                appStatus.textContent = "ì‹œì‘ì  RSSIë¥¼ ì…ë ¥í•˜ì„¸ìš”.";
                
                // ë°©í–¥ ì„¼ì„œ ê¶Œí•œ ìš”ì²­
                requestOrientationPermission();
                
                // ë Œë”ë§ ì‹œì‘
                requestAnimationFrame(draw);
            });

            submitRssiButton.addEventListener('click', () => {
                const rssiValue = parseFloat(rssiInput.value);
                if (isNaN(rssiValue)) { 
                    alert("ìœ íš¨í•œ RSSI ê°’ì„ ì…ë ¥í•˜ì„¸ìš”."); 
                    return; 
                }
                
                // ë¡œê·¸ ì—”íŠ¸ë¦¬ ìƒì„±
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    rssi_input: rssiValue,
                    state_before: algo.state,
                    pos_x: algo.pos.x.toFixed(2),
                    pos_y: algo.pos.y.toFixed(2),
                    waypoint_x_before: algo.waypoint.x.toFixed(2),
                    waypoint_y_before: algo.waypoint.y.toFixed(2),
                    stuck_counter: algo.stuck_counter,
                    estimated_velocity: kalmanFilter.getVelocity().toFixed(2),
                    filter_initialized: kalmanFilter.initialized,
                    phone_heading: phoneHeading.toFixed(1),
                    target_bearing: targetBearing.toFixed(1)
                };
                
                algo.decideAction(rssiValue);

                logEntry.state_after = algo.state;
                logEntry.waypoint_x_after = algo.waypoint.x.toFixed(2);
                logEntry.waypoint_y_after = algo.waypoint.y.toFixed(2);
                logData.push(logEntry);
                logCount.textContent = logData.length;
                
                rssiInput.value = '';
                if (algo.isFinished) {
                    appStatus.textContent = "ëª©í‘œ ì§€ì  ë„ì°©! í…ŒìŠ¤íŠ¸ ì¢…ë£Œ."; 
                    controlSection.style.display = 'none';
                } else {
                    isWaitingForRssi = false; 
                    controlSection.style.display = 'none';
                    appStatus.textContent = "ë‹¤ìŒ ëª©í‘œ ê³„ì‚° ì™„ë£Œ. ì´ë™í•˜ì„¸ìš”.";
                }
            });

            downloadLogButton.addEventListener('click', () => {
                if (logData.length === 0) {
                    alert("ê¸°ë¡ëœ ë¡œê·¸ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                    return;
                }
                const header = Object.keys(logData[0]).join(',');
                const rows = logData.map(row => Object.values(row).join(','));
                const csvContent = "data:text/csv;charset=utf-8," + header + "\n" + rows.join("\n");
                
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "gps_test_fixed_reception_log.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
            
            function setupCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth; 
                canvas.height = container.clientHeight;
            }

            // í˜ì´ì§€ ë¡œë“œì‹œ ì´ˆê¸°ê°’ ì„¤ì •
            setInitialValues();

            window.addEventListener('resize', setupCanvas);
            setupCanvas();

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                    handleGpsSuccess, 
                    (err) => { 
                        appStatus.textContent = `GPS ì˜¤ë¥˜: ${err.message}`;
                        console.error('GPS Error:', err);
                    }, 
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
                );
                startButton.style.display = 'none';
            } else {
                appStatus.textContent = "ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” GPSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
            }
        });
    </script>
</body>
</html>
